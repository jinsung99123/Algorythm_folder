//배열에서 두 숫자의 합이 target인 두 숫자의 인덱스를 반환.
//효율성을 위해 단순히 모든 쌍을 비교하는 O(n²) 방식보다 더 빠른 방법 필요.
//해시맵을 사용하여 각 숫자의 `필요한 값(target - 현재 숫자)`를 저장하고, 이를 기반으로 효율적으로 정답을 찾음.
//
/\*

### 2. 해결 방법

1. **초기화**:
   - 숫자와 인덱스를 저장하는 `Map<int, int>`(해시맵)를 생성.
2. **순회**:
   - 현재 숫자에 대해 `target - 현재 숫자`가 맵에 존재하는지 확인.
   - 존재하면 현재 숫자와 맵에서 찾은 숫자의 인덱스를 반환.
   - 존재하지 않으면 현재 숫자와 해당 인덱스를 맵에 추가.
3. **종료**:
   - 반드시 하나의 정답만 존재하므로 순회가 끝나기 전에 정답을 반환.

\*/

List<int> twoSum(List<int> nums, int target) {
Map<int, int> numMap = {}; // 숫자와 인덱스를 저장하는 `Map<int, int>`(해시맵)를 생성.

for (int i = 0; i < nums.length; i++) {  
 int complement = target - nums[i]; // 계산 코드

    if (numMap[complement] != null) { // 현재 숫자에 대해 `target - 현재 숫자`가 맵에 존재하는지 확인.
      return [numMap[complement]!, i]; // 존재하면 현재 숫자와 맵에서 찾은 숫자의 인덱스를 반환.
    }

    numMap[nums[i]] = i;  // 존재하지 않으면 현재 숫자와 해당 인덱스를 맵에 추가.

}

return []; // 반드시 하나의 정답만 존재하므로 순회가 끝나기 전에 정답을 반환.
}
